/*
 * Copyright 2020 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use crate::default_export_api_config::*;
use crate::errors::WITGeneratorError;
use crate::instructions_generator::WITGenerator;
use crate::instructions_generator::WITResolver;
use crate::Result;

/// Parse generated by rust-sdk AST types, generate instructions and embed them to Wasm file.
pub fn embed_wit(path: std::path::PathBuf) -> Result<()> {
    let wasm_module = walrus::ModuleConfig::new()
        .parse_file(path.clone())
        .map_err(|e| WITGeneratorError::IOError(format!("{:?} can't be parsed: {:?}", path, e)))?;

    let module_ast = wasm_ast_extractor(&wasm_module)?;
    let mut wit_resolver = WITResolver::default();
    generate_interfaces(&module_ast, &mut wit_resolver)?;

    let wasm_module = fce_wit_parser::delete_wit_section(wasm_module);

    let interfaces = wit_resolver.finalize();
    let mut wasm_module = fce_wit_parser::embed_wit(wasm_module, &interfaces);

    wasm_module.emit_wasm_file(path).map_err(|e| {
        WITGeneratorError::IOError(format!("resulted Wasm file can't be emitted: {:?}", e))
    })
}

pub(crate) struct ModuleAST {
    pub(crate) records: Vec<fluence_sdk_wit::AstRecordItem>,
    pub(crate) functions: Vec<fluence_sdk_wit::AstFunctionItem>,
    pub(crate) extern_mods: Vec<fluence_sdk_wit::AstExternModItem>,
}

/// Extract all custom AST types previously embedded by rust-sdk from compiled binary.
fn wasm_ast_extractor(wasm_module: &walrus::Module) -> Result<ModuleAST> {
    use fluence_sdk_wit::*;

    let mut records: Vec<AstRecordItem> = Vec::new();
    let mut functions: Vec<AstFunctionItem> = Vec::new();
    let mut extern_mods: Vec<AstExternModItem> = Vec::new();

    // consider only sections name of that starts with GENERATED_SECTION_PREFIX
    let custom_sections = wasm_module.customs.iter().filter(|(_, section)| {
        section
            .name()
            .starts_with(fluence_sdk_wit::GENERATED_SECTION_PREFIX)
    });

    for custom_section in custom_sections {
        let default_ids = walrus::IdsToIndices::default();
        let raw_data = custom_section.1.data(&default_ids);
        let decoded_json: FCEAst = serde_json::from_slice(&raw_data)?;
        match decoded_json {
            FCEAst::Record(record) => records.push(record),
            FCEAst::Function(function) => functions.push(function),
            FCEAst::ExternMod(extern_mod) => extern_mods.push(extern_mod),
        }
    }

    Ok(ModuleAST {
        records,
        functions,
        extern_mods,
    })
}

fn generate_interfaces<'ast, 'wit_resolver>(
    module_ast: &'ast ModuleAST,
    wit_resolver: &'wit_resolver mut WITResolver<'ast>,
) -> Result<()> {
    generate_default_export_api(wit_resolver);

    for record in &module_ast.records {
        record.generate_wit(wit_resolver)?;
    }
    wit_resolver.validate_records()?;

    for function in &module_ast.functions {
        function.generate_wit(wit_resolver)?;
    }
    for extern_mod in &module_ast.extern_mods {
        extern_mod.generate_wit(wit_resolver)?;
    }

    Ok(())
}

fn generate_default_export_api(wit_resolver: &mut WITResolver<'_>) {
    // TODO: the order is matter
    wit_resolver.insert_default_api(&ALLOCATE_FUNC);
    wit_resolver.insert_default_api(&DEALLOCATE_FUNC);
    wit_resolver.insert_default_api(&GET_RESULT_SIZE_FUNC);
    wit_resolver.insert_default_api(&GET_RESULT_PTR_FUNC);
    wit_resolver.insert_default_api(&SET_RESULT_SIZE_FUNC);
    wit_resolver.insert_default_api(&SET_RESULT_PTR_FUNC);
}
